package devtools;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import swg.crafting.Stat;
import swg.tools.ZNumber;
import swg.tools.ZXml;

/**
 * A utility to generate the Java source files for all the various resource
 * types. The resourcetree.xml is downloaded by SWGAide to
 * <SWGAide-folder>\crafting\ and provides the data for building resource
 * classes.
 * <P>
 * To just regenerate the class
 * swg.crafting.resources.SWGResourceClassInfo, see the boolean toggle
 * in {@link #generateFilesFromXML(Element, String, String, String)} just at the
 * call to
 * {@link #makeClassFile(PrintStream, String, String, String, String, String, String, Element)}.
 * <p>
 * <B>USE THIS CLASS AT YOUR OWN RISK</B>. It is not set up for an automated
 * build process just yet.
 * <p>
 * TODO: Fix so that this class will work dynamically with updates of
 * resourcetree.xml. Idea: move out some code from main() into another method
 * that can be called from a mainframe application.
 * 
 * @author Steven M. Doyle <shadow@triwizard.net>
 * @author <a href="mailto:simongronlund@gmail.com">Simon Gronlund</a> aka
 *         Chimaera.Zimoon
 */
public class SWGResourceClassGenerator {

    /**
     * Constant for end-of-line
     */
    // the ugly underscore to initiate it first in class
    private static final String _EOL = System.getProperty("line.separator");

    /**
     * JDocu header on author Shadow
     */
    private static final String authorShadow =
        " * @author Steven M. Doyle <shadow@triwizard.net>";

    /**
     * JDocu header on author Zimoon
     */
    private static final String authorZimoon =
        " * @author <a href=\"mailto:simongronlund@gmail.com\">"
            + "Simon Gronlund</a>" + _EOL + " * aka Chimaera.Zimoon";

    /**
     * The print stream for the list that maps a numeric SWGCraft ID to an
     * object of the wanted type, see SWGResourceClassInfo.swgIDtoInstance
     */
    private static PrintStream classIDtoInstance;

    /**
     * The print stream for the map that maps a proper resource class name and
     * its type token to their shared SWGCraft ID, see
     * SWGResourceClassInfo.swgTypeToClass
     */
    private static PrintStream classTypeToInt;

    /**
     * The package and import section for the class SWGResourceClassInfo
     */
    private static final String generatedImport =
        "package swg.crafting.resources;%n%n"
            + "import java.util.Arrays;%n" //
            + "import java.util.HashMap;%n" //
            + "import java.util.List;%n" //
            + "import java.util.Map;%n%n" //
            + "import swg.SWGAide;%n"
            + "import swg.crafting.resources.types.*;%n%n";

    /**
     * The header for each generated resource class; the proper JDocu header is
     * read in SWGResourceClass
     */
    private static final String generatedResourceClass =
        "/*%n * Represents a resource class of type "
            + "\"%s\"%n *%n%s%n *%n%s%n%s%n */%n";

    /**
     * The warning about auto-generation included in generated java file
     */
    private static final String generatedWarning =
        " * <b>WARNING:</b>" + _EOL
            + " * This class is generated by SWGResourceClassGenerator." + _EOL
            + " * Do not manually modify this class as your changes are" + _EOL
            + " * erased when the classes are re-generated.";

    /**
     * A counter for the highest resource class ID number used by SWGCraft,
     * which in its turn sets the size for
     */
    private static int highestID = 0;

    /**
     * The string fir the map that maps a numeric swgID (SWGCraft) to a Java
     * class of the wanted type
     */
    private static final String paramIDtoInstance =
        "  /**%n"
            + "   * Maps a numeric SWGCraft ID to an instance of a resource%n"
            + "   * class. This list contains {@code null} elements.%n"
            + "   */%n"
            + "  static final List<SWGResourceClass> swgIDtoInstance ="
            + " rcList(LISTSIZE + 1);%n%n";

    /**
     * The string for the static constant LISTSIZE, which is set by
     * {@link #highestID}
     */
    private static final String paramListSize =
        "  /**%n"
            + "   * The highest SWGCraft resource class ID, which maps to max%n"
            + "   * index for the list swgIDToInstance, thus the real list %n"
            + "   * size is {@code LISTSIZE + 1}%n   */%n"
            + "  static final int LISTSIZE = %d;%n%n";

    /**
     * The string for the map that maps a class name and its swgcraft_id to its
     * constructor
     */
    private static final String paramTypeToInt =
        "  /**%n"
            + "   * Maps a proper resource class name, or its type token, to%n"
            + "   * the numerical SWGCraft resource class ID%n" + "   */%n"
            + "  static final Map<String, Integer> swgTypeToInt =%n"
            + "      new HashMap<String, Integer>(%d);%n%n";

    /**
     * A reg exp pattern that normalizes resource class names to Java style
     */
    private static Pattern pkgNameFixer;

    /**
     * The method to initiate the indexed list for resource classes.
     */
    private static final String rcList = 
        "  /** @param n size%n"
            + "   * @return list */%n"  
            + "  private static List<SWGResourceClass> rcList(int n) {%n"  
            + "      SWGResourceClass[] rc = new SWGResourceClass[n];%n"  
            + "      Arrays.fill(rc, null);%n"
            + "      return Arrays.asList(rc);%n"  
            + "  }%n";

    /**
     * An index used in comparators for resource classes
     */
    private static int sortIndex = 0;

    /**
     * The text for the beginning the static block
     */
    private static final String staticBlockBegin =
        "  static {%n    try {%n      Integer sid;%n";

    /**
     * The text for the end of the static block
     */
    private static final String staticBlockEnd =
        "    } catch (Exception e) {%n"
            + "      SWGAide.printError(\"SWGResourceClassInfo:static_ini: \", e);%n"
            + "    }%n  }%n%n";

    /**
     * Parses a resource class from the XML Element and writes the result to the
     * different print writers and calls
     * {@link #makeClassFile(PrintStream, String, String, String, String, String, String, Element)}
     * to write the Java class to file
     * 
     * @param cur the current XML element
     * @param baseClass the parent class for the current class to be generated
     * @param packageBaseName the name of the Java package
     * @param packageBaseDir the target directory
     * @throws Exception some error
     */
    private static void generateFilesFromXML(Element cur, String baseClass,
            String packageBaseName, String packageBaseDir) throws Exception {

        String classToken = cur.getAttribute("swgcraft_id");
        String friendlyName = cur.getAttribute("description");
        String swgID = cur.getAttribute("swgID");
        Matcher pkgFix = pkgNameFixer.matcher(friendlyName);
        String className = "SWG" + pkgFix.replaceAll("");
        String classFileName = packageBaseDir + File.separator
                + packageBaseName.replace('.', File.separatorChar)
                + File.separator + className + ".java";

        // System.out.printf("%4d: %-6s %45s [%-70s] %s%n",
        System.out.printf("%4d: %-6s %-45s %s%n",
                Integer.valueOf(++sortIndex), classToken, className,
                /* classFileName, */ friendlyName);


        classTypeToInt.printf("      sid = Integer.valueOf(%3s); ", swgID);
        classTypeToInt.printf("swgTypeToInt.put(\"%s\", sid);%n", classToken);

        classTypeToInt.printf("%33s swgTypeToInt.put(\"%s\", sid);%n", " ",
                friendlyName);

        classIDtoInstance.printf(
                "      swgIDtoInstance.set(%3s, %s.getInstance());%n", swgID,
                className);

        // XXX: DEVELOPER_NOTE: toggle this on/off, off -> only
        // SWGResourceClassInfo is generated
        boolean createNewClassFiles = true;
        if (createNewClassFiles) {
            makeClassFile(new PrintStream(new FileOutputStream(new File(
                    classFileName))), baseClass, packageBaseName, className,
                    friendlyName, classToken, swgID, cur);
        }

        // Recursively carry on with subclasses from current resource type
        NodeList nl = cur.getChildNodes();
        for (int j = 0; j < nl.getLength(); ++j) {
            Node n = nl.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE
                    && n.getNodeName().equals("resource_type")) {

                generateFilesFromXML((Element) 
                        n, className, packageBaseName, packageBaseDir);
            }
        }

        int h = Integer.parseInt(swgID);
        if (h > highestID)
            highestID = h;
    }

    /**
     * Returns <code>value</code> if it is odd, or <code>value + 1</code> if
     * <code>value</code> is even; used to make odd-sized maps
     * 
     * @param value the value to oddify
     * @return <code>value</code> if it is odd, or <code>value + 1</code> if
     *         <code>value</code> is even
     */
    private static Integer getOdd(double value) {
        int v = (int) value;
        return Integer.valueOf(v | 1);
    }

    /**
     * Prints some help text at the console
     */
    private static void help() {
        System.out.println("Usage:");
        System.out.println(
                "  java SWGResourceClassGenerator <targetDir> <source_XML>");
        System.out.println("  Exiting");
        System.exit(0);
    }

    /**
     * The main method for generating resource classes
     * 
     * @param args the two arguments must be at the form
     *        <OL>
     *        <LI>target_directory</LI>
     *        <LI>source_xml_file</LI>
     *        </OL>
     *        For example:
     * 
     * <PRE>
     * java SWGResourceClassGenerator 
     *     C:\Documents and Settings\Simon\Projects\SWG
     *     C:\Documents and Settings\Simon\Projects\SWG\crafting\resourcetree2.xml
     * </PRE>
     */
    public static void main(String[] args) {
        // arg1: "C:\Documents and Settings\Simon Gronlund.SIMON\Projects\SWG"
        // arg2: "C:\Documents and Settings\Simon
        // Gronlund.SIMON\Projects\resourcetree2\resourcetree2.xml"
        if (args.length < 2)
            help();
        String targetDirectory = args[0];
        String sourceXML = args[1];

        System.out.println("Target directory:  " + targetDirectory);

        try {
            pkgNameFixer = Pattern.compile("\\W");

            ByteArrayOutputStream streamTypeToInt = new ByteArrayOutputStream();
            ByteArrayOutputStream streamIDtoInst = new ByteArrayOutputStream();
            ByteArrayOutputStream streamIDtoName = new ByteArrayOutputStream();

            classTypeToInt = new PrintStream(streamTypeToInt);
            classIDtoInstance = new PrintStream(streamIDtoInst);

            Document xml = ZXml.parse(new File(sourceXML));

            Element cur = (Element) xml.getElementsByTagName(
                    "resource_tree_data").item(0);

            String pkgName = "swg.crafting.resources.types";

            NodeList nl = cur.getChildNodes();
            for (int j = 0; j < nl.getLength(); ++j) {
                Node n = nl.item(j);
                if (n.getNodeType() == Node.ELEMENT_NODE
                        && n.getNodeName().equals("resource_type"))
                    generateFilesFromXML((Element) n, "SWGResourceClass",
                            pkgName, targetDirectory);
            }

            PrintStream staticClass =
                    new PrintStream(
                            new FileOutputStream(
                                    new File(
                                            targetDirectory
                                                    + String.format(
                                                            "%sswg%scrafting%sresources%sSWGResourceClassInfo.java",
                                                            File.separator,
                                                            File.separator,
                                                            File.separator,
                                                            File.separator))));
            staticClass.printf(generatedImport);
            staticClass.printf("/**%n");
            staticClass.printf(" * Static information used internally by "
                    + "various classes in%n"
                    + " * 'packages swg.crafting.resources' and its "
                    + "sub-package 'types'.%n");
            staticClass.printf(" * <p>%n");
            staticClass.printf(generatedWarning);
            staticClass.printf("%n%n%s%n%s%n */%n", authorShadow, authorZimoon);
            staticClass.printf("class SWGResourceClassInfo {%n%n");
            staticClass.printf(paramListSize, Integer.valueOf(highestID));
            staticClass.printf(paramIDtoInstance);
            staticClass.printf(paramTypeToInt, getOdd(highestID * 2.67));

            staticClass.printf(staticBlockBegin);
            staticClass.printf(streamTypeToInt.toString());
            staticClass.printf(_EOL);
            staticClass.printf(streamIDtoInst.toString());
            staticClass.printf(_EOL);
            staticClass.printf(_EOL);
            staticClass.printf(streamIDtoName.toString());
            staticClass.printf(staticBlockEnd);
            staticClass.printf(rcList);
            staticClass.printf("}%n");
            staticClass.close();
        } catch (Exception e) {
            System.err.print(e.getMessage());
            e.printStackTrace();
        }

        System.out.println("highest swgID: " + highestID);
    }

    /**
     * Writes a resource class to a Java file
     * 
     * @param out the print stream to write to
     * @param parent the name of the parent resource class for this resource
     *        class
     * @param pkg the name of the Java package
     * @param cls this resource class' Java class name
     * @param proper the proper name of the resource class
     * @param token the textual swgcraft_id, for this resource class, the
     *        classToken, named swgcraft_type_id in the resource export files
     *        from SWGCraft
     * @param swgID the numerical SWGCraft ID for this resource class
     * @param xml the XML element for this resource class that its stats will be
     *        parsed from
     * @throws Exception an error
     */
    private static void makeClassFile(PrintStream out, String parent,
            String pkg, String cls, String proper, String token, String swgID,
            Element xml) throws Exception {

        int childCount = xml.getChildNodes().getLength();
        String finalStr = childCount <= 0
                ? "final "
                : "";

        out.printf("package %s;%n%n", pkg);

        out.printf("import swg.crafting.resources.SWGResourceClass;%n");
        if (!parent.equals("SWGResourceClass"))
            out.printf("import swg.crafting.resources.types.%s;%n", parent);
        out.printf("import swg.crafting.Stat;%n%n");

        out.printf(generatedResourceClass, proper, generatedWarning,
                authorShadow, authorZimoon);
        out.printf("@SuppressWarnings(\"all\")%n");
        out.printf("public %sclass %s extends %s {%n%n", finalStr, cls, parent);

        out.printf("  private static final long serialVersionUID = %dL;%n%n",
                Long.valueOf(7919L + 7907L * Long.parseLong(swgID)));

        int[] minArr = new int[Stat.COUNT];
        int[] maxArr = new int[Stat.COUNT];

        int expectedStats = 0;
        int idx = 0;
        for (Stat s : Stat.values()) {
            String min = xml.getAttribute(s.getName() + "_min");
            String max = xml.getAttribute(s.getName() + "_max");

            int minInt = ZNumber.intExc(min);
            int maxInt = ZNumber.intExc(max);

            minArr[idx] = minInt;
            maxArr[idx] = maxInt;

            if (minInt > 0)
                ++expectedStats;

            ++idx;
        }
        String strMin = Arrays.toString(minArr);
        strMin = strMin.substring(1, strMin.length() - 1);
        out.printf("  private static final int[] minStats = {%s};%n", strMin);

        String strMax = Arrays.toString(maxArr);
        strMax = strMax.substring(1, strMax.length() - 1);
        out.printf("  private static final int[] maxStats = {%s};%n%n", strMax);

        out.printf("  private static final %s INSTANCE =", cls);
        out.printf(" new %s();%n%n", cls);

        out.printf("  %s() { super(); }%n%n", cls);

        out.printf("  public static %s getInstance() {", cls);
        out.printf(" return INSTANCE; }%n%n");

        out.printf("  public int expectedStats() { return %d; }%n",
                Integer.valueOf(expectedStats));

        out.printf("  public int sortIndex() { return %d; }%n", Integer
                .valueOf(sortIndex));

        out.printf("  public int rcID() { return %s; }%n", swgID);

        out.printf("  public String rcName() { return \"%s\";}%n", proper);

        out.printf("  public String rcToken() { return \"%s\";}%n", token);

        if (childCount <= 0) { // it is a leaf
            // only creature resource have attribute harvested=yes/no,
            // ignore all others, plus that no==false is default return value
            String harvested = xml.getAttribute("harvested");
            if (!harvested.isEmpty() && harvested.equalsIgnoreCase("yes")) {
                out.println("  public boolean isHarvested() { return true; }");
            }

            String recycled = xml.getAttribute("recycled");
            if (cls.contains("Asteroid")
                    || (!recycled.isEmpty() && recycled.equalsIgnoreCase("yes")))
                out.println("  public boolean isSpaceOrRecycled()  { return true; }");
            else
                // it is a leaf, all leafs are spawnable, except recycled
                out.println("  public boolean isSpawnable() { return true; }");
        }

        out.printf("  public boolean");
        out.printf(" has(Stat s) { return minStats[s.i] > 0; }%n");

        // default return value is false
        String jtl = xml.getAttribute("JTL");
        if (!jtl.isEmpty() && jtl.equalsIgnoreCase("yes")) {
            out.printf("  public boolean  isJTL() { return true; }%n%n");
        }

        out.printf("  public int max(Stat s) { return maxStats[s.i]; }%n");

        out.printf("  public int min(Stat s) { return minStats[s.i]; }%n%n");

        out.printf("  private Object readResolve() {%n");
        out.printf("    return INSTANCE; // preserve singleton property%n");
        out.printf("  }%n");

        out.printf("}%n");
    }
}
